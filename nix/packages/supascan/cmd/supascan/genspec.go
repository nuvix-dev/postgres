package main

import (
	"context"
	"fmt"
	"os"
	"time"

	"github.com/spf13/cobra"

	"github.com/supabase/supascan/internal/config"
	"github.com/supabase/supascan/internal/logger"
	"github.com/supabase/supascan/internal/scanners"
	"github.com/supabase/supascan/internal/spec"
)

var (
	// genspec flags
	configFile     string
	outputFormat   string
	includeDynamic bool
	includePorts   bool
	includeProcess bool
	shallowDirs    []string
	shallowDepth   int
	strict         bool
	verbose        bool
	debug          bool
	logFormat      string
)

var genspecCmd = &cobra.Command{
	Use:   "genspec [output-file]",
	Short: "Generate a baseline specification from the current system",
	Long: `Generate a machine baseline specification for system validation.

This command scans the system and generates a YAML or JSON specification file
containing packages, files, kernel parameters, services, users, groups, mounts,
and optionally listening ports and running processes.

Examples:
  # Generate default machine-baseline.yaml
  supascan genspec

  # Generate JSON output
  supascan genspec --format json baseline.json

  # Include dynamic checks with exclusions from config
  supascan genspec --config config.yaml --include-dynamic --include-ports

  # Enable verbose logging to stderr
  supascan genspec --verbose --log-format json

  # Scan directories without recursing into subdirectories (depth 1 = top level only)
  supascan genspec --shallow-dirs /nix/store --shallow-dirs /data/pgdata

  # Scan shallow dirs including immediate subdirectories (depth 2)
  supascan genspec --shallow-dirs /nix/store --shallow-depth 2
`,
	Args: cobra.MaximumNArgs(1),
	RunE: runGenspec,
}

func init() {
	genspecCmd.Flags().StringVar(&configFile, "config", "", "Load exclusions from config file")
	genspecCmd.Flags().StringVar(&outputFormat, "format", "yaml", "Output format: yaml or json")
	genspecCmd.Flags().BoolVar(&includeDynamic, "include-dynamic", false, "Include dynamic kernel parameters")
	genspecCmd.Flags().BoolVar(&includePorts, "include-ports", false, "Include listening ports")
	genspecCmd.Flags().BoolVar(&includeProcess, "include-processes", false, "Include running processes")
	genspecCmd.Flags().StringArrayVar(&shallowDirs, "shallow-dirs", nil, "Directories to scan with limited depth (can be specified multiple times)")
	genspecCmd.Flags().IntVar(&shallowDepth, "shallow-depth", 1, "How deep to scan in shallow dirs (1=top level only, 2=include immediate subdirs)")
	genspecCmd.Flags().BoolVar(&strict, "strict", false, "Fail on any access errors (default: skip and warn)")
	genspecCmd.Flags().BoolVar(&verbose, "verbose", false, "Enable structured logging to stderr")
	genspecCmd.Flags().BoolVar(&debug, "debug", false, "Enable debug logging (implies --verbose)")
	genspecCmd.Flags().StringVar(&logFormat, "log-format", "logfmt", "Log format: logfmt or json")

	rootCmd.AddCommand(genspecCmd)
}

func runGenspec(cmd *cobra.Command, args []string) error {
	// Default output file
	outputFile := "machine-baseline.yaml"
	if len(args) > 0 {
		outputFile = args[0]
	}

	// Setup structured logging
	if debug {
		verbose = true
	}
	scanLogger := logger.Setup(verbose, debug, logFormat)

	// Load configuration with CLI options
	cliOpts := config.CLIOptions{
		IncludeDynamic:   includeDynamic,
		IncludePorts:     includePorts,
		IncludeProcesses: includeProcess,
		ShallowDirs:      shallowDirs,
		ShallowDepth:     shallowDepth,
		ShallowDepthSet:  cmd.Flags().Changed("shallow-depth"),
	}
	cfg, err := config.Load(configFile, cliOpts)
	if err != nil {
		return fmt.Errorf("failed to load config: %w", err)
	}

	// Parse and validate output format
	var format spec.OutputFormat
	switch outputFormat {
	case "yaml":
		format = spec.FormatYAML
	case "json":
		format = spec.FormatJSON
	default:
		return fmt.Errorf("invalid output format: %s (must be yaml or json)", outputFormat)
	}

	// Create writer
	writer, err := spec.NewWriterWithFormat(outputFile, format)
	if err != nil {
		return fmt.Errorf("failed to create writer: %w", err)
	}
	defer writer.Close()

	// Get hostname for metadata
	hostname, err := os.Hostname()
	if err != nil {
		hostname = "unknown"
		scanLogger.Warn("Failed to get hostname", "error", err)
	}

	// Write header with metadata
	timestamp := time.Now().Format(time.RFC3339)
	header := fmt.Sprintf("Generated by supascan %s on %s at %s", version, hostname, timestamp)
	if err := writer.WriteHeader(header); err != nil {
		return fmt.Errorf("failed to write header: %w", err)
	}

	// Create scan options
	opts := scanners.ScanOptions{
		Writer:         writer,
		Config:         cfg,
		IncludeDynamic: includeDynamic,
		Strict:         strict,
		Logger:         scanLogger,
	}

	// Run all scanners
	ctx := context.Background()
	result, err := scanners.RunAll(ctx, opts)
	if err != nil {
		return fmt.Errorf("scan failed: %w", err)
	}

	// Handle warnings
	if len(result.Warnings) > 0 {
		if strict {
			scanLogger.Error("Scan completed with warnings", "warnings", len(result.Warnings))
			for _, warning := range result.Warnings {
				scanLogger.Warn(warning)
			}
			os.Exit(2)
		}
	}

	// Print summary
	scanLogger.Info("Scan completed successfully",
		"output_file", outputFile,
		"format", outputFormat,
		"scanners_run", result.ScannersRun,
		"files_scanned", result.FilesScanned,
		"files_skipped", result.FilesSkipped,
		"users_scanned", result.UsersScanned,
		"services_scanned", result.ServicesScanned,
		"warnings", len(result.Warnings),
		"duration", result.Duration,
	)

	// Exit with appropriate code
	if len(result.Warnings) > 0 {
		os.Exit(1)
	}

	return nil
}
